# AI 智能记事本 - 详细开发规划文档

## 项目概述

基于现有需求文档，本项目将开发一个集成AI功能的智能记事本应用，采用Vue.js 3 + Flask + SQLite的技术栈，具备赛博朋克风格的UI设计。

## 技术栈确认

- **前端**: Vue.js 3 + Vite + Tailwind CSS + TypeScript
- **后端**: Python 3 + Flask + SQLAlchemy
- **数据库**: SQLite
- **AI集成**: OpenRouter API
- **音频处理**: Whisper API

## 详细开发步骤

### 第1步：环境搭建与后端基础 (预计2-3天)

#### 1.1 环境准备
```bash
# 创建项目目录
mkdir ai-notebook
cd ai-notebook

# 创建后端目录
mkdir backend
cd backend

# 创建Python虚拟环境
python -m venv venv
venv\Scripts\activate  # Windows

# 安装依赖
pip install flask flask-sqlalchemy flask-cors python-dotenv requests
```

#### 1.2 Flask项目结构
```
backend/
├── app.py              # 主应用文件
├── models.py           # 数据模型
├── routes/
│   ├── __init__.py
│   ├── notes.py        # 笔记相关路由
│   ├── todos.py        # 待办事项路由
│   ├── ai.py           # AI功能路由
│   ├── audio.py        # 音频处理路由
│   └── settings.py     # 设置路由
├── utils/
│   ├── __init__.py
│   ├── ai_client.py    # OpenRouter客户端
│   └── audio_processor.py # 音频处理工具
├── database.db         # SQLite数据库文件
├── requirements.txt    # 依赖列表
└── .env               # 环境变量
```

#### 1.3 数据库模型设计
```python
# models.py
from flask_sqlalchemy import SQLAlchemy
from datetime import datetime

db = SQLAlchemy()

class Note(db.Model):
    __tablename__ = 'notes'
    
    id = db.Column(db.Integer, primary_key=True)
    title = db.Column(db.String(200), nullable=False)
    content = db.Column(db.Text, nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)
    updated_at = db.Column(db.DateTime, default=datetime.utcnow, onupdate=datetime.utcnow)
    
    # 关联的待办事项
    todos = db.relationship('Todo', backref='note', lazy=True, cascade='all, delete-orphan')

class Todo(db.Model):
    __tablename__ = 'todos'
    
    id = db.Column(db.Integer, primary_key=True)
    content = db.Column(db.Text, nullable=False)
    is_completed = db.Column(db.Boolean, default=False)
    source_note_id = db.Column(db.Integer, db.ForeignKey('notes.id'), nullable=True)
    created_at = db.Column(db.DateTime, default=datetime.utcnow)

class ChatHistory(db.Model):
    __tablename__ = 'chat_history'
    
    id = db.Column(db.Integer, primary_key=True)
    role = db.Column(db.String(20), nullable=False)  # 'user' or 'assistant'
    content = db.Column(db.Text, nullable=False)
    timestamp = db.Column(db.DateTime, default=datetime.utcnow)

class Setting(db.Model):
    __tablename__ = 'settings'
    
    key = db.Column(db.String(100), primary_key=True)
    value = db.Column(db.Text, nullable=True)
```

#### 1.4 基础API实现
```python
# routes/notes.py
from flask import Blueprint, request, jsonify
from models import db, Note

notes_bp = Blueprint('notes', __name__)

@notes_bp.route('/api/notes', methods=['GET'])
def get_notes():
    notes = Note.query.order_by(Note.updated_at.desc()).all()
    return jsonify([{
        'id': note.id,
        'title': note.title,
        'content': note.content,
        'created_at': note.created_at.isoformat(),
        'updated_at': note.updated_at.isoformat()
    } for note in notes])

@notes_bp.route('/api/notes', methods=['POST'])
def create_note():
    data = request.get_json()
    note = Note(
        title=data.get('title', '新笔记'),
        content=data.get('content', '')
    )
    db.session.add(note)
    db.session.commit()
    return jsonify({'id': note.id, 'message': '笔记创建成功'}), 201

@notes_bp.route('/api/notes/<int:note_id>', methods=['PUT'])
def update_note(note_id):
    note = Note.query.get_or_404(note_id)
    data = request.get_json()
    
    note.title = data.get('title', note.title)
    note.content = data.get('content', note.content)
    note.updated_at = datetime.utcnow()
    
    db.session.commit()
    return jsonify({'message': '笔记更新成功'})

@notes_bp.route('/api/notes/<int:note_id>', methods=['DELETE'])
def delete_note(note_id):
    note = Note.query.get_or_404(note_id)
    db.session.delete(note)
    db.session.commit()
    return jsonify({'message': '笔记删除成功'})
```

### 第2步：前端基础与笔记功能 (预计3-4天)

#### 2.1 Vue.js项目创建
```bash
# 回到项目根目录
cd ..

# 创建Vue项目
npm create vue@latest frontend
cd frontend
npm install

# 安装额外依赖
npm install tailwindcss @tailwindcss/typography axios pinia
npm install -D @types/node
```

#### 2.2 项目结构
```
frontend/
├── src/
│   ├── components/
│   │   ├── Navigation.vue
│   │   ├── NoteList.vue
│   │   ├── NoteEditor.vue
│   │   ├── TodoCard.vue
│   │   ├── TodoItem.vue
│   │   ├── AIContextMenu.vue
│   │   └── AIAssistantWidget.vue
│   ├── views/
│   │   ├── NotebookView.vue
│   │   ├── TodoView.vue
│   │   └── SettingsView.vue
│   ├── stores/
│   │   ├── notes.js
│   │   ├── todos.js
│   │   ├── settings.js
│   │   └── theme.js
│   ├── utils/
│   │   ├── api.js
│   │   └── constants.js
│   ├── styles/
│   │   ├── cyberpunk.css
│   │   └── animations.css
│   ├── App.vue
│   └── main.js
├── tailwind.config.js
└── package.json
```

#### 2.3 Tailwind配置（赛博朋克主题）
```javascript
// tailwind.config.js
module.exports = {
  content: ['./index.html', './src/**/*.{vue,js,ts,jsx,tsx}'],
  darkMode: 'class',
  theme: {
    extend: {
      colors: {
        cyber: {
          dark: '#0A192F',
          primary: '#64FFDA',
          secondary: '#F57DFF',
          accent: '#00D9FF',
          warning: '#FFD700',
          danger: '#FF6B6B'
        }
      },
      fontFamily: {
        cyber: ['Orbitron', 'monospace'],
        mono: ['Share Tech Mono', 'monospace']
      },
      animation: {
        glow: 'glow 2s ease-in-out infinite alternate',
        scan: 'scan 2s linear infinite'
      },
      keyframes: {
        glow: {
          '0%': { boxShadow: '0 0 5px #64FFDA, 0 0 10px #64FFDA' },
          '100%': { boxShadow: '0 0 10px #64FFDA, 0 0 20px #64FFDA, 0 0 30px #64FFDA' }
        },
        scan: {
          '0%': { transform: 'translateX(-100%)' },
          '100%': { transform: 'translateX(100%)' }
        }
      }
    }
  },
  plugins: []
}
```

#### 2.4 核心组件实现
```vue
<!-- src/components/NoteEditor.vue -->
<template>
  <div class="note-editor cyber-panel">
    <div class="editor-header">
      <input 
        v-model="currentNote.title" 
        class="cyber-input title-input"
        placeholder="笔记标题"
        @input="debouncedSave"
      />
      <button class="cyber-btn audio-btn" @click="uploadAudio">
        <i class="icon-microphone"></i>
        音频分析
      </button>
    </div>
    
    <textarea 
      v-model="currentNote.content"
      class="cyber-textarea content-editor"
      placeholder="开始记录你的想法..."
      @input="debouncedSave"
      @contextmenu="showAIMenu"
    ></textarea>
    
    <AIContextMenu 
      v-if="showMenu" 
      :position="menuPosition"
      :selected-text="selectedText"
      @close="showMenu = false"
      @action="handleAIAction"
    />
  </div>
</template>

<script setup>
import { ref, computed, watch } from 'vue'
import { useNotesStore } from '@/stores/notes'
import { debounce } from 'lodash-es'
import AIContextMenu from './AIContextMenu.vue'

const notesStore = useNotesStore()
const currentNote = computed(() => notesStore.currentNote)

const showMenu = ref(false)
const menuPosition = ref({ x: 0, y: 0 })
const selectedText = ref('')

// 防抖保存
const debouncedSave = debounce(() => {
  if (currentNote.value?.id) {
    notesStore.updateNote(currentNote.value.id, {
      title: currentNote.value.title,
      content: currentNote.value.content
    })
  }
}, 1000)

// AI上下文菜单
const showAIMenu = (event) => {
  const selection = window.getSelection()
  if (selection.toString().trim()) {
    event.preventDefault()
    selectedText.value = selection.toString()
    menuPosition.value = { x: event.clientX, y: event.clientY }
    showMenu.value = true
  }
}

const handleAIAction = async (action) => {
  // 调用AI处理选中文本
  await notesStore.processTextWithAI(selectedText.value, action)
  showMenu.value = false
}

const uploadAudio = () => {
  // 音频上传逻辑
  const input = document.createElement('input')
  input.type = 'file'
  input.accept = 'audio/*'
  input.onchange = async (e) => {
    const file = e.target.files[0]
    if (file) {
      await notesStore.analyzeAudio(file)
    }
  }
  input.click()
}
</script>
```

### 第3步：设置与主题切换 (预计1-2天)

#### 3.1 设置页面实现
```vue
<!-- src/views/SettingsView.vue -->
<template>
  <div class="settings-view cyber-container">
    <h1 class="cyber-title">系统设置</h1>
    
    <div class="settings-grid">
      <!-- API配置 -->
      <div class="setting-card cyber-panel">
        <h3>AI配置</h3>
        <div class="form-group">
          <label>OpenRouter API Key</label>
          <input 
            v-model="settings.openrouter_api_key"
            type="password"
            class="cyber-input"
            placeholder="请在此输入你的API密钥"
          />
        </div>
        <div class="form-group">
          <label>默认AI模型</label>
          <select v-model="settings.default_llm" class="cyber-select">
            <option value="anthropic/claude-3-sonnet">Claude 3 Sonnet</option>
            <option value="openai/gpt-4">GPT-4</option>
            <option value="meta-llama/llama-2-70b-chat">Llama 2 70B</option>
          </select>
        </div>
      </div>
      
      <!-- 主题设置 -->
      <div class="setting-card cyber-panel">
        <h3>界面设置</h3>
        <div class="form-group">
          <label>主题模式</label>
          <div class="theme-switcher">
            <button 
              :class="['theme-btn', { active: !isDark }]"
              @click="setTheme('light')"
            >
              <i class="icon-sun"></i>
              亮色模式
            </button>
            <button 
              :class="['theme-btn', { active: isDark }]"
              @click="setTheme('dark')"
            >
              <i class="icon-moon"></i>
              暗色模式
            </button>
          </div>
        </div>
      </div>
      
      <!-- 功能开关 -->
      <div class="setting-card cyber-panel">
        <h3>功能设置</h3>
        <div class="form-group">
          <label class="switch-label">
            <input 
              v-model="settings.enable_ai_assistant"
              type="checkbox"
              class="cyber-switch"
            />
            启用AI助手浮动球
          </label>
        </div>
        <div class="form-group">
          <label class="switch-label">
            <input 
              v-model="settings.auto_save"
              type="checkbox"
              class="cyber-switch"
            />
            自动保存笔记
          </label>
        </div>
      </div>
    </div>
    
    <div class="settings-actions">
      <button class="cyber-btn primary" @click="saveSettings">
        保存设置
      </button>
      <button class="cyber-btn secondary" @click="resetSettings">
        重置默认
      </button>
    </div>
  </div>
</template>

<script setup>
import { ref, computed, onMounted } from 'vue'
import { useSettingsStore } from '@/stores/settings'
import { useThemeStore } from '@/stores/theme'

const settingsStore = useSettingsStore()
const themeStore = useThemeStore()

const settings = ref({
  openrouter_api_key: '', // 用户在设置页面输入
  default_llm: 'anthropic/claude-3-sonnet',
  enable_ai_assistant: true,
  auto_save: true
})

const isDark = computed(() => themeStore.isDark)

const setTheme = (theme) => {
  themeStore.setTheme(theme)
}

const saveSettings = async () => {
  await settingsStore.updateSettings(settings.value)
  // 显示保存成功提示
}

const resetSettings = () => {
  settings.value = {
    openrouter_api_key: '', // 保留用户输入的密钥
    default_llm: 'anthropic/claude-3-sonnet',
    enable_ai_assistant: true,
    auto_save: true
  }
}

onMounted(async () => {
  const savedSettings = await settingsStore.getSettings()
  Object.assign(settings.value, savedSettings)
})
</script>
```

### 第4步：上下文AI功能 (预计2-3天)

#### 4.1 后端AI客户端
```python
# utils/ai_client.py
import requests
import json
from flask import current_app

class OpenRouterClient:
    def __init__(self, api_key):
        self.api_key = api_key
        self.base_url = "https://openrouter.ai/api/v1"
        
    def chat_completion(self, messages, model="anthropic/claude-3-sonnet"):
        headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json",
            "HTTP-Referer": "http://localhost:5173",  # Vite默认端口
            "X-Title": "AI Notebook"
        }
        
        data = {
            "model": model,
            "messages": messages
        }
        
        response = requests.post(
            f"{self.base_url}/chat/completions",
            headers=headers,
            json=data
        )
        
        if response.status_code == 200:
            return response.json()["choices"][0]["message"]["content"]
        else:
            raise Exception(f"API调用失败: {response.text}")
    
    def process_text(self, text, action):
        prompts = {
            "summarize": f"请总结以下文本的要点：\n\n{text}",
            "polish": f"请润色和改写以下文本，使其更加流畅和专业：\n\n{text}",
            "translate_en": f"请将以下文本翻译成英文：\n\n{text}",
            "translate_zh": f"请将以下文本翻译成中文：\n\n{text}",
            "translate_ms": f"请将以下文本翻译成马来文：\n\n{text}"
        }
        
        if action not in prompts:
            raise ValueError(f"不支持的操作: {action}")
        
        messages = [
            {"role": "user", "content": prompts[action]}
        ]
        
        return self.chat_completion(messages)
```

#### 4.2 AI功能路由
```python
# routes/ai.py
from flask import Blueprint, request, jsonify
from models import db, Setting
from utils.ai_client import OpenRouterClient

ai_bp = Blueprint('ai', __name__)

@ai_bp.route('/api/ai/action', methods=['POST'])
def process_text():
    data = request.get_json()
    text = data.get('text')
    action = data.get('action')
    
    if not text or not action:
        return jsonify({'error': '缺少必要参数'}), 400
    
    # 获取API密钥
    api_key_setting = Setting.query.filter_by(key='openrouter_api_key').first()
    if not api_key_setting or not api_key_setting.value:
        return jsonify({'error': '请先配置OpenRouter API密钥'}), 400
    
    try:
        client = OpenRouterClient(api_key_setting.value)
        result = client.process_text(text, action)
        return jsonify({'result': result})
    except Exception as e:
        return jsonify({'error': str(e)}), 500

@ai_bp.route('/api/ai/chat', methods=['POST'])
def chat():
    data = request.get_json()
    messages = data.get('messages', [])
    model = data.get('model', 'anthropic/claude-3-sonnet')
    
    # 获取API密钥
    api_key_setting = Setting.query.filter_by(key='openrouter_api_key').first()
    if not api_key_setting or not api_key_setting.value:
        return jsonify({'error': '请先配置OpenRouter API密钥'}), 400
    
    try:
        client = OpenRouterClient(api_key_setting.value)
        response = client.chat_completion(messages, model)
        return jsonify({'response': response})
    except Exception as e:
        return jsonify({'error': str(e)}), 500
```

### 第5步：待办事项模块 (预计1-2天)

#### 5.1 待办事项组件
```vue
<!-- src/components/TodoCard.vue -->
<template>
  <div class="todo-card cyber-panel">
    <div class="card-header">
      <h3 class="card-title">{{ source || '手动添加' }}</h3>
      <span class="todo-count">{{ completedCount }}/{{ totalCount }}</span>
    </div>
    
    <div class="todo-list">
      <TodoItem 
        v-for="todo in todos"
        :key="todo.id"
        :todo="todo"
        @toggle="toggleTodo"
        @delete="deleteTodo"
      />
    </div>
    
    <div class="card-actions">
      <button class="cyber-btn small" @click="addTodo">
        <i class="icon-plus"></i>
        添加任务
      </button>
    </div>
  </div>
</template>

<script setup>
import { computed } from 'vue'
import { useTodosStore } from '@/stores/todos'
import TodoItem from './TodoItem.vue'

const props = defineProps({
  source: String,
  todos: Array
})

const todosStore = useTodosStore()

const totalCount = computed(() => props.todos.length)
const completedCount = computed(() => 
  props.todos.filter(todo => todo.is_completed).length
)

const toggleTodo = async (todoId) => {
  await todosStore.toggleTodo(todoId)
}

const deleteTodo = async (todoId) => {
  await todosStore.deleteTodo(todoId)
}

const addTodo = () => {
  // 添加新待办事项的逻辑
  const content = prompt('请输入待办事项内容：')
  if (content) {
    todosStore.createTodo({ content, source_note_id: null })
  }
}
</script>
```

### 第6步：音频分析工作流 (预计3-4天)

#### 6.1 音频处理后端
```python
# utils/audio_processor.py
import requests
import tempfile
import os
from utils.ai_client import OpenRouterClient

class AudioProcessor:
    def __init__(self, openrouter_api_key):
        self.ai_client = OpenRouterClient(openrouter_api_key)
    
    def transcribe_audio(self, audio_file):
        """使用Whisper API转录音频"""
        # 这里需要实现Whisper API调用
        # 或者使用OpenAI的Whisper API
        headers = {
            "Authorization": f"Bearer {self.ai_client.api_key}"
        }
        
        files = {
            "file": audio_file,
            "model": (None, "whisper-1")
        }
        
        response = requests.post(
            "https://api.openai.com/v1/audio/transcriptions",
            headers=headers,
            files=files
        )
        
        if response.status_code == 200:
            return response.json()["text"]
        else:
            raise Exception(f"音频转录失败: {response.text}")
    
    def analyze_transcript(self, transcript):
        """分析转录文本，提取会议纪要和待办事项"""
        prompt = f"""
请分析以下会议录音的转录文本，并按照以下格式输出：

## 会议纪要
[总结会议的主要内容、讨论要点和决定]

## 待办事项
[提取出具体的行动项目，每行一个，格式为：- 任务描述]

转录文本：
{transcript}

请确保输出格式严格按照上述要求。
"""
        
        messages = [
            {"role": "user", "content": prompt}
        ]
        
        return self.ai_client.chat_completion(messages)
    
    def extract_todos_from_analysis(self, analysis_text):
        """从分析结果中提取待办事项列表"""
        lines = analysis_text.split('\n')
        todos = []
        in_todo_section = False
        
        for line in lines:
            line = line.strip()
            if '## 待办事项' in line:
                in_todo_section = True
                continue
            elif line.startswith('## ') and in_todo_section:
                break
            elif in_todo_section and line.startswith('- '):
                todo_content = line[2:].strip()
                if todo_content:
                    todos.append(todo_content)
        
        return todos
```

#### 6.2 音频分析路由
```python
# routes/audio.py
from flask import Blueprint, request, jsonify
from werkzeug.utils import secure_filename
from models import db, Note, Todo, Setting
from utils.audio_processor import AudioProcessor
import tempfile
import os
from datetime import datetime

audio_bp = Blueprint('audio', __name__)

@audio_bp.route('/api/audio/analyze', methods=['POST'])
def analyze_audio():
    if 'audio' not in request.files:
        return jsonify({'error': '没有上传音频文件'}), 400
    
    audio_file = request.files['audio']
    if audio_file.filename == '':
        return jsonify({'error': '没有选择文件'}), 400
    
    # 获取API密钥
    api_key_setting = Setting.query.filter_by(key='openrouter_api_key').first()
    if not api_key_setting or not api_key_setting.value:
        return jsonify({'error': '请先配置OpenRouter API密钥'}), 400
    
    try:
        # 保存临时文件
        with tempfile.NamedTemporaryFile(delete=False, suffix='.wav') as tmp_file:
            audio_file.save(tmp_file.name)
            
            # 处理音频
            processor = AudioProcessor(api_key_setting.value)
            
            # 转录音频
            with open(tmp_file.name, 'rb') as f:
                transcript = processor.transcribe_audio(f)
            
            # 分析转录文本
            analysis = processor.analyze_transcript(transcript)
            
            # 提取待办事项
            todos_list = processor.extract_todos_from_analysis(analysis)
            
            # 创建新笔记
            note_title = f"会议纪要 {datetime.now().strftime('%Y-%m-%d %H:%M')}"
            note_content = f"## 原始转录\n\n{transcript}\n\n{analysis}"
            
            new_note = Note(title=note_title, content=note_content)
            db.session.add(new_note)
            db.session.flush()  # 获取note.id
            
            # 创建待办事项
            todos_added = 0
            for todo_content in todos_list:
                todo = Todo(
                    content=todo_content,
                    source_note_id=new_note.id
                )
                db.session.add(todo)
                todos_added += 1
            
            db.session.commit()
            
            # 清理临时文件
            os.unlink(tmp_file.name)
            
            return jsonify({
                'message': '音频分析完成',
                'newNoteId': new_note.id,
                'todosAdded': todos_added
            })
            
    except Exception as e:
        return jsonify({'error': f'音频处理失败: {str(e)}'}), 500
```

### 第7步：全局AI助手 (预计2-3天)

#### 7.1 可拖动AI助手组件
```vue
<!-- src/components/AIAssistantWidget.vue -->
<template>
  <div class="ai-assistant-widget">
    <!-- 浮动球 -->
    <div 
      ref="floatingBall"
      class="floating-ball"
      :class="{ active: showChat }"
      @mousedown="startDrag"
      @click="toggleChat"
    >
      <div class="ball-glow"></div>
      <i class="icon-robot"></i>
    </div>
    
    <!-- 聊天窗口 -->
    <Transition name="chat-slide">
      <div v-if="showChat" class="chat-window cyber-panel">
        <div class="chat-header">
          <h3>AI 助手</h3>
          <div class="chat-controls">
            <select v-model="selectedModel" class="model-selector">
              <option value="anthropic/claude-3-sonnet">Claude 3 Sonnet</option>
              <option value="openai/gpt-4">GPT-4</option>
              <option value="meta-llama/llama-2-70b-chat">Llama 2</option>
            </select>
            <button @click="showChat = false" class="close-btn">
              <i class="icon-close"></i>
            </button>
          </div>
        </div>
        
        <div class="chat-messages" ref="messagesContainer">
          <div 
            v-for="message in messages" 
            :key="message.id"
            :class="['message', message.role]"
          >
            <div class="message-content">
              {{ message.content }}
            </div>
            <div class="message-time">
              {{ formatTime(message.timestamp) }}
            </div>
          </div>
          
          <div v-if="isLoading" class="message assistant loading">
            <div class="typing-indicator">
              <span></span><span></span><span></span>
            </div>
          </div>
        </div>
        
        <div class="chat-input">
          <textarea 
            v-model="inputMessage"
            placeholder="输入你的问题..."
            @keydown.enter.prevent="sendMessage"
            @keydown.shift.enter="inputMessage += '\n'"
            class="cyber-textarea"
          ></textarea>
          <button 
            @click="sendMessage" 
            :disabled="!inputMessage.trim() || isLoading"
            class="send-btn cyber-btn"
          >
            <i class="icon-send"></i>
          </button>
        </div>
      </div>
    </Transition>
  </div>
</template>

<script setup>
import { ref, reactive, nextTick, onMounted, onUnmounted } from 'vue'
import { useAIStore } from '@/stores/ai'

const aiStore = useAIStore()

const floatingBall = ref(null)
const messagesContainer = ref(null)
const showChat = ref(false)
const selectedModel = ref('anthropic/claude-3-sonnet')
const inputMessage = ref('')
const isLoading = ref(false)
const messages = ref([])

// 拖拽相关
const isDragging = ref(false)
const dragOffset = reactive({ x: 0, y: 0 })

const startDrag = (e) => {
  if (e.button !== 0) return // 只响应左键
  
  isDragging.value = true
  const rect = floatingBall.value.getBoundingClientRect()
  dragOffset.x = e.clientX - rect.left
  dragOffset.y = e.clientY - rect.top
  
  document.addEventListener('mousemove', onDrag)
  document.addEventListener('mouseup', stopDrag)
  
  e.preventDefault()
}

const onDrag = (e) => {
  if (!isDragging.value) return
  
  const x = e.clientX - dragOffset.x
  const y = e.clientY - dragOffset.y
  
  // 限制在视窗范围内
  const maxX = window.innerWidth - 60
  const maxY = window.innerHeight - 60
  
  const constrainedX = Math.max(0, Math.min(x, maxX))
  const constrainedY = Math.max(0, Math.min(y, maxY))
  
  floatingBall.value.style.left = `${constrainedX}px`
  floatingBall.value.style.top = `${constrainedY}px`
}

const stopDrag = () => {
  isDragging.value = false
  document.removeEventListener('mousemove', onDrag)
  document.removeEventListener('mouseup', stopDrag)
}

const toggleChat = () => {
  if (!isDragging.value) {
    showChat.value = !showChat.value
    if (showChat.value) {
      loadChatHistory()
    }
  }
}

const sendMessage = async () => {
  if (!inputMessage.value.trim() || isLoading.value) return
  
  const userMessage = {
    id: Date.now(),
    role: 'user',
    content: inputMessage.value,
    timestamp: new Date()
  }
  
  messages.value.push(userMessage)
  inputMessage.value = ''
  isLoading.value = true
  
  try {
    const response = await aiStore.sendChatMessage(
      messages.value.map(m => ({ role: m.role, content: m.content })),
      selectedModel.value
    )
    
    const assistantMessage = {
      id: Date.now() + 1,
      role: 'assistant',
      content: response,
      timestamp: new Date()
    }
    
    messages.value.push(assistantMessage)
    
    // 保存聊天记录
    await aiStore.saveChatHistory(userMessage, assistantMessage)
    
  } catch (error) {
    console.error('发送消息失败:', error)
    // 显示错误提示
  } finally {
    isLoading.value = false
    scrollToBottom()
  }
}

const loadChatHistory = async () => {
  try {
    messages.value = await aiStore.getChatHistory()
    nextTick(() => scrollToBottom())
  } catch (error) {
    console.error('加载聊天记录失败:', error)
  }
}

const scrollToBottom = () => {
  nextTick(() => {
    if (messagesContainer.value) {
      messagesContainer.value.scrollTop = messagesContainer.value.scrollHeight
    }
  })
}

const formatTime = (timestamp) => {
  return new Date(timestamp).toLocaleTimeString('zh-CN', {
    hour: '2-digit',
    minute: '2-digit'
  })
}

onMounted(() => {
  // 设置初始位置
  floatingBall.value.style.position = 'fixed'
  floatingBall.value.style.right = '20px'
  floatingBall.value.style.bottom = '20px'
  floatingBall.value.style.zIndex = '9999'
})

onUnmounted(() => {
  document.removeEventListener('mousemove', onDrag)
  document.removeEventListener('mouseup', stopDrag)
})
</script>

<style scoped>
.floating-ball {
  width: 60px;
  height: 60px;
  border-radius: 50%;
  background: linear-gradient(135deg, #64FFDA, #F57DFF);
  display: flex;
  align-items: center;
  justify-content: center;
  cursor: pointer;
  transition: all 0.3s ease;
  box-shadow: 0 4px 20px rgba(100, 255, 218, 0.3);
  position: relative;
  overflow: hidden;
}

.floating-ball:hover {
  transform: scale(1.1);
  box-shadow: 0 6px 30px rgba(100, 255, 218, 0.5);
}

.floating-ball.active {
  background: linear-gradient(135deg, #F57DFF, #64FFDA);
}

.ball-glow {
  position: absolute;
  top: -50%;
  left: -50%;
  width: 200%;
  height: 200%;
  background: radial-gradient(circle, rgba(100, 255, 218, 0.3) 0%, transparent 70%);
  animation: glow 2s ease-in-out infinite alternate;
}

.chat-window {
  position: fixed;
  right: 100px;
  bottom: 20px;
  width: 400px;
  height: 500px;
  background: rgba(10, 25, 47, 0.95);
  border: 1px solid #64FFDA;
  border-radius: 10px;
  display: flex;
  flex-direction: column;
  backdrop-filter: blur(10px);
  z-index: 9998;
}

.chat-header {
  padding: 15px;
  border-bottom: 1px solid #64FFDA;
  display: flex;
  justify-content: space-between;
  align-items: center;
}

.chat-messages {
  flex: 1;
  padding: 15px;
  overflow-y: auto;
  display: flex;
  flex-direction: column;
  gap: 10px;
}

.message {
  max-width: 80%;
  padding: 10px 15px;
  border-radius: 10px;
  position: relative;
}

.message.user {
  align-self: flex-end;
  background: linear-gradient(135deg, #64FFDA, #00D9FF);
  color: #0A192F;
}

.message.assistant {
  align-self: flex-start;
  background: rgba(245, 125, 255, 0.1);
  border: 1px solid #F57DFF;
  color: #64FFDA;
}

.chat-input {
  padding: 15px;
  border-top: 1px solid #64FFDA;
  display: flex;
  gap: 10px;
}

.chat-input textarea {
  flex: 1;
  min-height: 40px;
  max-height: 100px;
  resize: none;
}

.typing-indicator {
  display: flex;
  gap: 4px;
  padding: 10px;
}

.typing-indicator span {
  width: 8px;
  height: 8px;
  border-radius: 50%;
  background: #64FFDA;
  animation: typing 1.4s infinite ease-in-out;
}

.typing-indicator span:nth-child(1) { animation-delay: -0.32s; }
.typing-indicator span:nth-child(2) { animation-delay: -0.16s; }

@keyframes typing {
  0%, 80%, 100% { transform: scale(0); }
  40% { transform: scale(1); }
}

.chat-slide-enter-active,
.chat-slide-leave-active {
  transition: all 0.3s ease;
}

.chat-slide-enter-from,
.chat-slide-leave-to {
  opacity: 0;
  transform: translateX(100px) scale(0.8);
}
</style>
```

### 第8步：最终打磨与优化 (预计2-3天)

#### 8.1 赛博朋克样式完善
```css
/* src/styles/cyberpunk.css */
:root {
  --cyber-primary: #64FFDA;
  --cyber-secondary: #F57DFF;
  --cyber-accent: #00D9FF;
  --cyber-dark: #0A192F;
  --cyber-darker: #020c1b;
  --cyber-light: #8892b0;
  --cyber-white: #ccd6f6;
}

/* 全局样式 */
.cyber-container {
  background: linear-gradient(135deg, var(--cyber-dark) 0%, var(--cyber-darker) 100%);
  min-height: 100vh;
  color: var(--cyber-white);
  font-family: 'Orbitron', monospace;
  position: relative;
  overflow-x: hidden;
}

.cyber-container::before {
  content: '';
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  background-image: 
    linear-gradient(90deg, transparent 98%, var(--cyber-primary) 100%),
    linear-gradient(0deg, transparent 98%, var(--cyber-primary) 100%);
  background-size: 50px 50px;
  opacity: 0.03;
  pointer-events: none;
  z-index: 1;
}

/* 面板样式 */
.cyber-panel {
  background: rgba(10, 25, 47, 0.8);
  border: 1px solid var(--cyber-primary);
  border-radius: 0;
  clip-path: polygon(0 0, calc(100% - 20px) 0, 100% 20px, 100% 100%, 20px 100%, 0 calc(100% - 20px));
  backdrop-filter: blur(10px);
  position: relative;
  overflow: hidden;
}

.cyber-panel::before {
  content: '';
  position: absolute;
  top: 0;
  left: -100%;
  width: 100%;
  height: 100%;
  background: linear-gradient(90deg, transparent, rgba(100, 255, 218, 0.1), transparent);
  transition: left 0.5s;
}

.cyber-panel:hover::before {
  left: 100%;
}

/* 按钮样式 */
.cyber-btn {
  background: linear-gradient(135deg, var(--cyber-primary), var(--cyber-accent));
  color: var(--cyber-dark);
  border: none;
  padding: 12px 24px;
  font-family: 'Orbitron', monospace;
  font-weight: 600;
  text-transform: uppercase;
  letter-spacing: 1px;
  cursor: pointer;
  position: relative;
  overflow: hidden;
  transition: all 0.3s ease;
  clip-path: polygon(0 0, calc(100% - 10px) 0, 100% 10px, 100% 100%, 10px 100%, 0 calc(100% - 10px));
}

.cyber-btn:hover {
  transform: translateY(-2px);
  box-shadow: 0 10px 20px rgba(100, 255, 218, 0.3);
}

.cyber-btn:active {
  transform: translateY(0);
}

.cyber-btn.secondary {
  background: linear-gradient(135deg, var(--cyber-secondary), #ff6b9d);
}

/* 输入框样式 */
.cyber-input,
.cyber-textarea {
  background: rgba(10, 25, 47, 0.5);
  border: 1px solid var(--cyber-primary);
  color: var(--cyber-white);
  padding: 12px 16px;
  font-family: 'Share Tech Mono', monospace;
  font-size: 14px;
  outline: none;
  transition: all 0.3s ease;
  clip-path: polygon(0 0, calc(100% - 5px) 0, 100% 5px, 100% 100%, 5px 100%, 0 calc(100% - 5px));
}

.cyber-input:focus,
.cyber-textarea:focus {
  border-color: var(--cyber-accent);
  box-shadow: 0 0 10px rgba(100, 255, 218, 0.3);
  background: rgba(10, 25, 47, 0.8);
}

.cyber-input::placeholder,
.cyber-textarea::placeholder {
  color: var(--cyber-light);
  opacity: 0.7;
}

/* 标题样式 */
.cyber-title {
  font-family: 'Orbitron', monospace;
  font-size: 2.5rem;
  font-weight: 900;
  text-transform: uppercase;
  letter-spacing: 3px;
  background: linear-gradient(135deg, var(--cyber-primary), var(--cyber-secondary));
  -webkit-background-clip: text;
  -webkit-text-fill-color: transparent;
  background-clip: text;
  position: relative;
  margin-bottom: 2rem;
}

.cyber-title::after {
  content: '';
  position: absolute;
  bottom: -10px;
  left: 0;
  width: 100px;
  height: 3px;
  background: linear-gradient(90deg, var(--cyber-primary), transparent);
}

/* 动画效果 */
@keyframes glow {
  0% { box-shadow: 0 0 5px var(--cyber-primary); }
  50% { box-shadow: 0 0 20px var(--cyber-primary), 0 0 30px var(--cyber-primary); }
  100% { box-shadow: 0 0 5px var(--cyber-primary); }
}

@keyframes scan {
  0% { transform: translateX(-100%); }
  100% { transform: translateX(100vw); }
}

.glow-animation {
  animation: glow 2s ease-in-out infinite alternate;
}

/* 扫描线效果 */
.scan-line {
  position: fixed;
  top: 0;
  left: 0;
  width: 2px;
  height: 100vh;
  background: linear-gradient(to bottom, transparent, var(--cyber-primary), transparent);
  animation: scan 3s linear infinite;
  z-index: 9999;
  pointer-events: none;
}

/* 响应式设计 */
@media (max-width: 768px) {
  .cyber-container {
    padding: 1rem;
  }
  
  .cyber-title {
    font-size: 1.8rem;
    letter-spacing: 2px;
  }
  
  .cyber-panel {
    margin-bottom: 1rem;
  }
}

/* 滚动条样式 */
::-webkit-scrollbar {
  width: 8px;
}

::-webkit-scrollbar-track {
  background: var(--cyber-dark);
}

::-webkit-scrollbar-thumb {
  background: linear-gradient(135deg, var(--cyber-primary), var(--cyber-secondary));
  border-radius: 4px;
}

::-webkit-scrollbar-thumb:hover {
  background: linear-gradient(135deg, var(--cyber-secondary), var(--cyber-primary));
}
```

## 部署和测试

### 开发环境运行
```bash
# 后端
cd backend
python app.py

# 前端
cd frontend
npm run dev
```

### 生产环境部署
```bash
# 构建前端
cd frontend
npm run build

# 配置Flask服务静态文件
# 或使用Nginx代理
```

## 总结

这个开发规划提供了完整的实施路径，从基础环境搭建到最终的UI优化。每个步骤都包含了具体的代码示例和实现细节。建议按照步骤顺序进行开发，确保每个阶段都经过充分测试后再进入下一阶段。

关键技术点：
1. **前后端分离架构**：Vue.js + Flask
2. **实时数据同步**：使用Pinia状态管理
3. **AI集成**：OpenRouter API统一接口
4. **音频处理**：Whisper + LLM分析流程
5. **赛博朋克UI**：CSS动画 + 渐变效果
6. **响应式设计**：适配多种设备

预计总开发时间：15-20天（单人开发）

## 重要技术实现说明

### 开关按钮实现规范

**⚠️ 重要：开关按钮的正确实现方式**

在Settings.vue中，所有开关按钮（自动保存、通知、声音等）必须使用以下实现方式：

```vue
<!-- 正确的实现方式 -->
<label class="flex items-center space-x-4 cursor-pointer group" @click.prevent="toggleAutoSave">
  <div class="relative">
    <input 
      type="checkbox" 
      class="sr-only"
      :checked="settings.autoSave"
      readonly
    >
    <!-- 自定义开关UI -->
  </div>
  <span>{{ languageService.t('enable_auto_save') }}</span>
</label>
```

**❌ 错误的实现方式（会导致双重触发）：**
```vue
<!-- 错误：同时使用v-model和@click.prevent -->
<input v-model="settings.autoSave" type="checkbox" @click.prevent="toggleAutoSave">
```

**技术原理：**
- 使用 `:checked` 属性绑定而不是 `v-model`
- 添加 `readonly` 属性防止直接操作
- 通过 `@click.prevent` 和对应的 toggle 函数控制状态
- 避免 v-model 和点击事件的双重触发导致开关自动回转

**对应的JavaScript实现：**
```javascript
const toggleAutoSave = () => {
  isManualToggle = true
  settings.value.autoSave = !settings.value.autoSave
  settingsService.setSetting('autoSave', settings.value.autoSave, updateAutoSaveStatus, false)
  setTimeout(() => { isManualToggle = false }, 100)
}
```

此实现方式确保开关按钮行为正确，避免状态冲突和自动回转问题。